<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content />
    <meta name="author" content />
    <title>Megaparsec | Fun with the recovery feature</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="../css/megaparsec.css" />
  </head>

  <body>

    <div class="navbar navbar-default navbar-static-top" role="navigation">
      <div class="container-fluid">
        <div class="navbar-header">
          <a class="navbar-brand" href="../">
            Megaparsec
          </a>
        </div>
        <div class="navbar-right">
          <ul class="nav navbar-nav">
            
            <li>
              <a href="../tutorials.html">Tutorials</a>
            </li>
            
            <li>
              <a href="https://hackage.haskell.org/package/megaparsec">Hackage</a>
            </li>
            
            <li>
              <a href="https://github.com/mrkkrp/megaparsec">GitHub</a>
            </li>
            
            <li>
              <a href="https://github.com/mrkkrp/megaparsec-site">Edit the site</a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="row-fluid">
        <div class="col-sm-10 col-sm-offset-1 col-md-8 col-md-offset-2 main">
          <div class="page-header">
            <h1>Fun with the recovery feature
              
              <br />
              <small>
                Skip errors and report multiple errors at once
              </small>
              
            </h1>
            <hr />
            <div class="content">
              
<em>Last updated on January  1, 2017</em>
<hr />


<p>Megaparsec 4.4.0 is a major improvement of the library. Among other things, it provides new primitive combinator <code>withRecovery</code> that allows to recover from parse errors “on-the-fly” and report several errors after parsing is finished or ignore them altogether. In this tutorial, we will learn how to use this incredible tool.</p>
<ol style="list-style-type: decimal">
<li><a href="#language-that-we-will-parse">Language that we will parse</a></li>
<li><a href="#parser-without-recovery">Parser without recovery</a></li>
<li><a href="#making-use-of-the-recovery-feature">Making use of the recovery feature</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ol>
<h2 id="language-that-we-will-parse">Language that we will parse</h2>
<p>For the purposes of this tutorial, we will write parser for a simplistic functional language that consists only of equations with symbol on the left hand side and arithmetic expression on the right hand side:</p>
<pre><code>y = 10
x = 3 * (1 + y)

result = x - 1 # answer is 32</code></pre>
<p>Here, it can only calculate arithmetic expressions, but if we were to design something more powerful, we could introduce more interesting operators to grab input from console, etc., but since our aim is to explore new parsing feature, this language will do.</p>
<p>First, we will write parser that can parse entire program in this language as list of ASTs representing equations. Then we will make it failure-tolerant in a way, so when it cannot parse particular equation, it does not stop, but continues its work until all input is analyzed.</p>
<h2 id="parser-without-recovery">Parser without recovery</h2>
<p>The parser is very easy to write. We will need the following imports:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies     #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span> (empty)
<span class="kw">import </span><span class="dt">Control.Monad</span> (void)
<span class="kw">import </span><span class="dt">Data.Scientific</span> (toRealFloat)
<span class="kw">import </span><span class="dt">Text.Megaparsec</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.String</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.Expr</span>
<span class="kw">import qualified</span> <span class="dt">Text.Megaparsec.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></code></pre></div>
<p>To represent AST of our language we will use these definitions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Program</span> <span class="fu">=</span> [<span class="dt">Equation</span>]

<span class="kw">data</span> <span class="dt">Equation</span> <span class="fu">=</span> <span class="dt">Equation</span> <span class="dt">String</span> <span class="dt">Expr</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Value</span>          <span class="dt">Double</span>
  <span class="fu">|</span> <span class="dt">Reference</span>      <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">Negation</span>       <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Sum</span>            <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Subtraction</span>    <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Multiplication</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Division</span>       <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>It’s obvious that a program in our language is collection of equations, where every equation gives name to expression which in turn can be simply a number, reference to other equation, or some math involving those concepts.</p>
<p>As usual, first thing that we need to handle when starting a parser is white space. We will have two space-consuming parsers:</p>
<ul>
<li><p><code>scn</code> — consumes newlines and white space in general. We will use it for white space between equations, which will start with a newline (since equations are newline-delimited).</p></li>
<li><p><code>sc</code> — this does not consume newlines and is used to define lexemes, i.e. things that automatically eat white space after them.</p></li>
</ul>
<p>Here is what I’ve got:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lineComment ::</span> <span class="dt">Parser</span> ()
lineComment <span class="fu">=</span> L.skipLineComment <span class="st">&quot;#&quot;</span>

<span class="ot">scn ::</span> <span class="dt">Parser</span> ()
scn <span class="fu">=</span> L.space (void spaceChar) lineComment empty

<span class="ot">sc ::</span> <span class="dt">Parser</span> ()
sc <span class="fu">=</span> L.space (void <span class="fu">$</span> oneOf <span class="st">&quot; \t&quot;</span>) lineComment empty

<span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
lexeme <span class="fu">=</span> L.lexeme sc

<span class="ot">symbol ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
symbol <span class="fu">=</span> L.symbol sc</code></pre></div>
<p>Consult Haddocks for description of <code>L.space</code>, <code>L.lexeme</code>, and <code>L.symbol</code>. In short, <code>L.space</code> is a helper to quickly put together general-purpose space-consuming parser. We will follow this strategy: <em>assume no white space before lexemes and consume all white space after lexemes</em>. There is a case with white space that can be found before any lexeme, but that will be dealt with specially, see below.</p>
<p>We also need a parser for equation names (<code>x</code>, <code>y</code>, and <code>result</code> in the first example). Like in many other programming languages, we will accept alpha-numeric sequences that do not start with a number:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">name ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
name <span class="fu">=</span> lexeme ((<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> letterChar <span class="fu">&lt;*&gt;</span> many alphaNumChar) <span class="fu">&lt;?&gt;</span> <span class="st">&quot;name&quot;</span></code></pre></div>
<p>All too easy. Parsing of expressions could slow us down, but there is a solution out-of-box in <code>Text.Megaparsec.Expr</code> module:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
expr <span class="fu">=</span> makeExprParser term table <span class="fu">&lt;?&gt;</span> <span class="st">&quot;expression&quot;</span>

<span class="ot">term ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span>
term <span class="fu">=</span> parens expr
  <span class="fu">&lt;|&gt;</span> (<span class="dt">Reference</span> <span class="fu">&lt;$&gt;</span> name)
  <span class="fu">&lt;|&gt;</span> (<span class="dt">Value</span>     <span class="fu">&lt;$&gt;</span> number)

<span class="ot">table ::</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span>]]
table <span class="fu">=</span>
  [ [<span class="dt">Prefix</span> (<span class="dt">Negation</span> <span class="fu">&lt;$</span> symbol <span class="st">&quot;-&quot;</span>) ]
  , [ <span class="dt">InfixL</span> (<span class="dt">Multiplication</span> <span class="fu">&lt;$</span> symbol <span class="st">&quot;*&quot;</span>)
    , <span class="dt">InfixL</span> (<span class="dt">Subtraction</span>    <span class="fu">&lt;$</span> symbol <span class="st">&quot;/&quot;</span>) ]
  , [ <span class="dt">InfixL</span> (<span class="dt">Sum</span>            <span class="fu">&lt;$</span> symbol <span class="st">&quot;+&quot;</span>)
    , <span class="dt">InfixL</span> (<span class="dt">Division</span>       <span class="fu">&lt;$</span> symbol <span class="st">&quot;-&quot;</span>) ]
  ]

<span class="ot">number ::</span> <span class="dt">Parser</span> <span class="dt">Double</span>
number <span class="fu">=</span> toRealFloat <span class="fu">&lt;$&gt;</span> lexeme L.number

<span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
parens <span class="fu">=</span> between (symbol <span class="st">&quot;(&quot;</span>) (symbol <span class="st">&quot;)&quot;</span>)</code></pre></div>
<p>We just wrote fairly complete parser for expressions in our language! If you’re new to all this stuff I suggest you load the code into GHCi and play with it a bit. Use <code>parseTest</code> function to feed input into the parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> parseTest expr <span class="st">&quot;5&quot;</span>
<span class="dt">Value</span> <span class="fl">5.0</span>
λ<span class="fu">&gt;</span> parseTest expr <span class="st">&quot;5 + foo&quot;</span>
<span class="dt">Sum</span> (<span class="dt">Value</span> <span class="fl">5.0</span>) (<span class="dt">Reference</span> <span class="st">&quot;foo&quot;</span>)
λ<span class="fu">&gt;</span> parseTest expr <span class="st">&quot;(x + y) * 5 + 7 * z&quot;</span>
<span class="dt">Sum</span>
  (<span class="dt">Multiplication</span> (<span class="dt">Sum</span> (<span class="dt">Reference</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Reference</span> <span class="st">&quot;y&quot;</span>)) (<span class="dt">Value</span> <span class="fl">5.0</span>))
  (<span class="dt">Multiplication</span> (<span class="dt">Value</span> <span class="fl">7.0</span>) (<span class="dt">Reference</span> <span class="st">&quot;z&quot;</span>))</code></pre></div>
<p>Power! The only thing that remains is a parser for equations and a parser for entire program:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">equation ::</span> <span class="dt">Parser</span> <span class="dt">Equation</span>
equation <span class="fu">=</span> <span class="dt">Equation</span> <span class="fu">&lt;$&gt;</span> (name <span class="fu">&lt;*</span> symbol <span class="st">&quot;=&quot;</span>) <span class="fu">&lt;*&gt;</span> expr

<span class="ot">prog ::</span> <span class="dt">Parser</span> <span class="dt">Program</span>
prog <span class="fu">=</span> between scn eof (sepEndBy equation scn)</code></pre></div>
<p>Note that we need to consume leading white-space in <code>prog</code> manually, as described above. Try the <code>prog</code> parser — it’s a complete solution that can parse language we described in the beginning. Parsing “end of file” <code>eof</code> explicitly makes the parser consume all input and fail loudly if it cannot do it, otherwise it would just stop on the first problematic token and return what it has parsed so far.</p>
<h2 id="making-use-of-the-recovery-feature">Making use of the recovery feature</h2>
<p>Our parser is really dandy, it has nice error messages and does its job well. However, every expression is clearly separated from the others by a newline. This separation makes it possible to analyze many expressions independently, even if one of them is malformed, we have no reason to stop and not to check the others. In fact, that’s how some “serious” parsers work (parser of C++ language, although it depends on compiler I guess). Reporting multiple parse errors at once may be more efficient method of communication with programmer that needs to fix them than when he has to recompile the program every time to get to the next error. In this section we will make our parser failure-tolerant and able to report multiple error messages at once.</p>
<p>Let’s add one more type synonym — <code>RawData</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">RawData</span> t e <span class="fu">=</span> [<span class="dt">Either</span> (<span class="dt">ParseError</span> t e) <span class="dt">Equation</span>]</code></pre></div>
<p>This represents a collection of equations, just like <code>Program</code>, but every one of them may be malformed: in that case we get original error message in <code>Left</code>, otherwise we have properly parsed equation in <code>Right</code>.</p>
<p>You will be amazed just how easy it is to add recovering to existing parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rawData ::</span> <span class="dt">Parser</span> (<span class="dt">RawData</span> <span class="dt">Char</span> <span class="dt">Dec</span>)
rawData <span class="fu">=</span> between scn eof (sepEndBy e scn)
  <span class="kw">where</span> e <span class="fu">=</span> withRecovery recover (<span class="dt">Right</span> <span class="fu">&lt;$&gt;</span> equation)
        recover err <span class="fu">=</span> <span class="dt">Left</span> err <span class="fu">&lt;$</span> manyTill anyChar eol</code></pre></div>
<p>Let try it, here is the input:</p>
<pre><code>foo = (x $ y) * 5 + 7.2 * z
bar = 15</code></pre>
<p>Result:</p>
<pre><code>[ Left
   (ParseError
     { errorPos = SourcePos
       { sourceName = &quot;&quot;, sourceLine = Pos 1
       , sourceColumn = Pos 10} :| []
       , errorUnexpected = fromList [Tokens ('$' :| &quot;&quot;)]
       , errorExpected = fromList
         [ Tokens (')' :| &quot;&quot;)
         , Label ('o' :| &quot;perator&quot;)
         , Label ('r' :| &quot;est of expression&quot;) ]
       , errorCustom = fromList [] })
, Right (Equation &quot;bar&quot; (Value 15.0)) ]</code></pre>
<p>How does it work? <code>withRecovery r p</code> primitive runs parser <code>p</code> as usual, but if it fails, it just takes its <code>ParseError</code> and provides it as argument of <code>r</code>. In <code>r</code> you start right were <code>p</code> failed — no backtracking happens, because it would make it harder to find position from where to start normal parsing again. Here you have a chance to consume some input to advance parser’s textual position. In our case it’s as simple as eating all input up to the next newline, but it might be trickier.</p>
<p>You probably want to know now what happens when recovering parser <code>r</code> fails as well. The answer is: your parser fails as usual, as if no <code>withRecovery</code> primitive was used. It’s by design that recovering parser cannot influence error messages in any way, or it would lead to quite confusing error messages in some cases, depending on logic of recovering parser.</p>
<p>Now it’s up to you what to do with <code>RawData</code>. You can either take all error messages and print them one by one, or ignore altogether and filter only valid equations to work with.</p>
<h2 id="conclusion">Conclusion</h2>
<p>When you want to use <code>withRecovery</code>, the main thing to remember that parts of text that you want to allow to fail should be clearly separated from each other, so recovering parser can reliably skip to the next part if current part cannot be parsed. In a language like Python, you could use indentation levels to tell apart high-level definitions, for example. In every case you should use your judgment and creativity to decide how to make use of <code>withRecovery</code>. In some cases it may be not worth it, but more often than not you will be able to improve experience of people who work with your product by using this new Megaparsec’s feature.</p>


<hr />
<p>
  (Psst! Looking for source code for this tutorial?
  It's <a href="https://github.com/mrkkrp/megaparsec-site/tree/master/tutorial-code/RecoveryFeature.hs">here</a>.)
</p>


            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.1.0/anchor.min.js"></script>
    <script src="../js/put-anchors.js"></script>
  </body>
</html>
