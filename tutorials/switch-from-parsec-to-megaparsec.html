<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content />
    <meta name="author" content />
    <title>Megaparsec | Switch from Parsec to Megaparsec</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="../css/megaparsec.css" />
  </head>

  <body>

    <div class="navbar navbar-default navbar-static-top" role="navigation">
      <div class="container-fluid">
        <div class="navbar-header">
          <a class="navbar-brand" href="../">
            Megaparsec
          </a>
        </div>
        <div class="navbar-right">
          <ul class="nav navbar-nav">
            
            <li>
              <a href="../tutorials.html">Tutorials</a>
            </li>
            
            <li>
              <a href="https://hackage.haskell.org/package/megaparsec">Hackage</a>
            </li>
            
            <li>
              <a href="https://github.com/mrkkrp/megaparsec">GitHub</a>
            </li>
            
            <li>
              <a href="https://github.com/mrkkrp/megaparsec-site">Edit the site</a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="row-fluid">
        <div class="col-sm-10 col-sm-offset-1 col-md-8 col-md-offset-2 main">
          <div class="page-header">
            <h1>Switch from Parsec to Megaparsec
              
              <br />
              <small>
                Practical recommendations
              </small>
              
            </h1>
            <hr />
            <div class="content">
              
<em>Last updated on May 14, 2016</em>
<hr />


<p>Some progressive Haskell hackers may wish to switch from Parsec to Megaparsec. This tutorial explains the practical differences between the two libraries that you will need to address if you choose to undertake the switch. Remember, all the functionality available in Parsec is available in Megaparsec and often in a better form.</p>
<ol style="list-style-type: decimal">
<li><a href="#imports">Imports</a></li>
<li><a href="#renamed-things">Renamed things</a></li>
<li><a href="#removed-things">Removed things</a></li>
<li><a href="#completely-changed-things">Completely changed things</a></li>
<li><a href="#other">Other</a></li>
<li><a href="#character-parsing">Character parsing</a></li>
<li><a href="#expression-parsing">Expression parsing</a></li>
<li><a href="#what-happened-to-text.parsec.token">What happened to <code>Text.Parsec.Token</code>?</a></li>
<li><a href="#whats-next">What’s next?</a></li>
</ol>
<h2 id="imports">Imports</h2>
<p>You’ll mainly need to replace “Parsec” part in your imports with “Megaparsec”. That’s pretty simple. Typical import section of module that uses Megaparsec looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- this module contains commonly useful tools:</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec</span>
<span class="co">-- this module depends on type of data you want to parse, you only need to</span>
<span class="co">-- import one of these:</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.String</span>          <span class="co">-- if you parse ‘String’</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.ByteString</span>      <span class="co">-- if you parse strict ‘ByteString’</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.ByteString.Lazy</span> <span class="co">-- if you parse lazy ‘ByteString’</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.Text</span>            <span class="co">-- if you parse strict ‘Text’</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.Text.Lazy</span>       <span class="co">-- if you parse lazy ‘Text’</span>
<span class="co">-- if you need to parse permutation phrases:</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.Perm</span>
<span class="co">-- if you need to parse expressions:</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.Expr</span>
<span class="co">-- if you need to parse languages:</span>
<span class="kw">import qualified</span> <span class="dt">Text.Megaparsec.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></code></pre></div>
<p>So, the only noticeable difference that Megaparsec has no <code>Text.Megaparsec.Token</code> module which is replaced with <code>Text.Megaparsec.Lexer</code>, see about this in section <a href="#what-happened-to-text.parsec.token">“What happened to <code>Text.Parsec.Token</code>”</a>.</p>
<h2 id="renamed-things">Renamed things</h2>
<p>Megaparsec introduces a more consistent naming scheme, so some things are called differently, but renaming functions is a very easy task, you don’t need to think. Here are renamed items:</p>
<ul>
<li><code>many1</code> → <code>some</code> (re-exported from <code>Control.Applicative</code>)</li>
<li><code>skipMany1</code> → <code>skipSome</code></li>
<li><code>tokenPrim</code> → <code>token</code></li>
<li><code>optionMaybe</code> → <code>optional</code> (re-exported from <code>Control.Applicative</code>)</li>
<li><code>permute</code> → <code>makePermParser</code></li>
<li><code>buildExpressionParser</code> → <code>makeExprParser</code></li>
</ul>
<p>Character parsing:</p>
<ul>
<li><code>alphaNum</code> → <code>alphaNumChar</code></li>
<li><code>digit</code> → <code>digitChar</code></li>
<li><code>endOfLine</code> → <code>eol</code></li>
<li><code>hexDigit</code> → <code>hexDigitChar</code></li>
<li><code>letter</code> → <code>letterChar</code></li>
<li><code>lower</code> → <code>lowerChar</code></li>
<li><code>octDigit</code> → <code>octDigitChar</code></li>
<li><code>space</code> → <code>spaceChar</code> †</li>
<li><code>spaces</code> → <code>space</code> †</li>
<li><code>upper</code> → <code>upperChar</code></li>
</ul>
<p>† — pay attention to these, since <code>space</code> parses <em>many</em> <code>spaceChar</code>s, including zero, if you write something like <code>many space</code>, your parser will hang. So be careful to replace <code>many space</code> with either <code>many spaceChar</code> or <code>spaces</code>.</p>
<h2 id="removed-things">Removed things</h2>
<p>Parsec also has many names for the same or similar things. Megaparsec usually has one function per task that does its job well. Here are the items that were removed in Megaparsec and reasons of their removal:</p>
<ul>
<li><p><code>parseFromFile</code> — from file and then parsing its contents is trivial for every instance of <code>Stream</code> and this function provides no way to use newer methods for running a parser, such as <code>runParser'</code>.</p></li>
<li><p><code>getState</code>, <code>putState</code>, <code>modifyState</code> — ad-hoc backtracking user state has been eliminated.</p></li>
<li><p><code>unexpected</code>, <code>token</code> and <code>tokens</code>, now there is a bit different versions of these functions under the same name.</p></li>
<li><p><code>Reply</code> and <code>Consumed</code> are not public data types anymore, because they are low-level implementation details.</p></li>
<li><p><code>runPT</code> and <code>runP</code> were essentially synonyms for <code>runParserT</code> and <code>runParser</code> respectively.</p></li>
<li><p><code>chainl</code>, <code>chainl1</code>, <code>chainr</code>, and <code>chainr1</code> — use <a href="https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Expr.html"><code>Text.Megaparsec.Expr</code></a> instead.</p></li>
</ul>
<h2 id="completely-changed-things">Completely changed things</h2>
<p>In Megaparsec 5 the modules <code>Text.Megaparsec.Pos</code> and <code>Text.Megaparsec.Error</code> are completely different from those found in Parsec and Megaparsec 4. Take some time to look at documentation of the modules if your use-case requires operations on error messages or positions. You may like the fact that we have well-typed and extensible error messages now.</p>
<h2 id="other">Other</h2>
<ul>
<li><p>The <code>Stream</code> type class now have <code>updatePos</code> method that gives precise control over advancing of textual positions during parsing.</p></li>
<li><p>Note that argument order of <code>label</code> has been flipped (the label itself goes first now), so you can write now: <code>myParser = label &quot;my parser&quot; $ …</code>.</p></li>
<li><p>Don’t use the <code>label &quot;&quot;</code> (or the <code>… &lt;?&gt; &quot;&quot;</code>) idiom to “hide” some “expected” tokens from error messages, use <code>hidden</code>.</p></li>
<li><p>New <code>token</code> parser is more powerful, its first argument provides full control over reported error message while its second argument allows to specify how to report missing token in case of empty input stream.</p></li>
<li><p>Now <code>tokens</code> parser allows to control how tokens are compared (yes, we have case-insensitive <code>string</code> called <code>string'</code>).</p></li>
<li><p>The <code>unexpected</code> parser allows to specify precisely what is unexpected in well-typed manner.</p></li>
<li><p>Tab width is not hard-coded anymore, use <code>getTabWidth</code> and <code>setTabWidth</code> to change it. Default tab width is <code>defaultTabWidth</code>.</p></li>
<li><p>Now you can reliably test error messages, equality for them is now defined properly (in Parsec <code>Expect &quot;foo&quot;</code> is equal to <code>Expect &quot;bar&quot;</code>), error messages are also well-typed and customizeable.</p></li>
<li><p>To render a error message, apply <code>parseErrorPretty</code> on it.</p></li>
<li><p><code>count' m n p</code> allows you to parse from <code>m</code> to <code>n</code> occurrences of <code>p</code>.</p></li>
<li><p>Now you have <code>someTill</code> and <code>eitherP</code> out of the box.</p></li>
<li><p><code>token</code>-based combinators like <code>string</code> and <code>string'</code> backtrack by default, so it’s not necessary to use <code>try</code> with them (beginning from <code>4.4.0</code>). This feature does not affect performance.</p></li>
<li><p>The new <code>failure</code> combinator allows to fail with an arbitrary error message, it even allows to use your own data types.</p></li>
</ul>
<h2 id="character-parsing">Character parsing</h2>
<p>New character parsers in <a href="https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Char.html"><code>Text.Megaparsec.Char</code></a> may be useful if you work with Unicode:</p>
<ul>
<li><code>asciiChar</code></li>
<li><code>charCategory</code></li>
<li><code>controlChar</code></li>
<li><code>latin1Char</code></li>
<li><code>markChar</code></li>
<li><code>numberChar</code></li>
<li><code>printChar</code></li>
<li><code>punctuationChar</code></li>
<li><code>separatorChar</code></li>
<li><code>symbolChar</code></li>
</ul>
<p>Ever wanted to have case-insensitive character parsers? Here you go:</p>
<ul>
<li><code>char'</code></li>
<li><code>oneOf'</code></li>
<li><code>noneOf'</code></li>
<li><code>string'</code></li>
</ul>
<h2 id="expression-parsing">Expression parsing</h2>
<p><code>makeExprParser</code> has flipped order of arguments: term parser first, operator table second. To specify associativity of infix operators you use one of the three <code>Operator</code> constructors:</p>
<ul>
<li><code>InfixN</code> — non-associative infix</li>
<li><code>InfixL</code> — left-associative infix</li>
<li><code>InfixR</code> — right-associative infix</li>
</ul>
<h2 id="what-happened-to-text.parsec.token">What happened to <code>Text.Parsec.Token</code>?</h2>
<p>That module was extremely inflexible and thus it has been eliminated. In Megaparsec you have <a href="https://hackage.haskell.org/package/megaparsec/docs/Text-Megaparsec-Lexer.html"><code>Text.Megaparsec.Lexer</code></a> instead, which doesn’t impose anything on user but provides useful helpers. The module can also parse indentation-sensitive languages.</p>
<p>Let’s quickly describe how you go about writing your lexer with <code>Text.Megaparsec.Lexer</code>. First, you should import the module qualified, we will use <code>L</code> as its synonym here.</p>
<h3 id="white-space">White space</h3>
<p>Start writing your lexer by defining what counts as <em>white space</em> in your language. <code>space</code>, <code>skipLineComment</code>, and <code>skipBlockComment</code> can be helpful:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sc ::</span> <span class="dt">Parser</span> () <span class="co">-- ‘sc’ stands for “space consumer”</span>
sc <span class="fu">=</span> L.space (void spaceChar) lineComment blockComment
  <span class="kw">where</span> lineComment  <span class="fu">=</span> L.skipLineComment <span class="st">&quot;//&quot;</span>
        blockComment <span class="fu">=</span> L.skipBlockComment <span class="st">&quot;/*&quot;</span> <span class="st">&quot;*/&quot;</span></code></pre></div>
<p>This is generally called <em>space consumer</em>, often you’ll need only one space consumer, but you can define as many of them as you want. Note that this new module allows you avoid consuming newline characters automatically, just use something different than <code>void spaceChar</code> as first argument of <code>space</code>. Even better, you can control what white space is on per-lexeme basis:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
lexeme <span class="fu">=</span> L.lexeme sc

<span class="ot">symbol ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
symbol <span class="fu">=</span> L.symbol sc</code></pre></div>
<h3 id="monad-transformers">Monad transformers</h3>
<p>Note that all tools in Megaparsec work with any instance of <code>MonadParsec</code>. All commonly useful monad transformers like <code>StateT</code> and <code>WriterT</code> are instances of <code>MonadParsec</code> out of the box. For example, what if you want to collect contents of comments, (say, they are documentation strings of a sort), you may want to have backtracking user state were you put last encountered comment satisfying some criteria, and then when you parse function definition you can check the state and attach doc-string to your parsed function. It’s all possible and easy with Megaparsec:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.State.Lazy</span>

…

<span class="kw">type</span> <span class="dt">MyParser</span> <span class="fu">=</span> <span class="dt">StateT</span> <span class="dt">String</span> <span class="dt">Parser</span>

<span class="ot">skipLineComment' ::</span> <span class="dt">MyParser</span> ()
skipLineComment' <span class="fu">=</span> …

<span class="ot">skipBlockComment' ::</span> <span class="dt">MyParser</span> ()
skipBlockComment' <span class="fu">=</span> …

<span class="ot">sc ::</span> <span class="dt">MyParser</span> ()
sc <span class="fu">=</span> space (void spaceChar) skipLineComment' skipBlockComment'</code></pre></div>
<h3 id="indentation-sensitive-languages">Indentation-sensitive languages</h3>
<p>Parsing of indentation-sensitive language deserves its own tutorial, but let’s take a look at basic tools upon which you can build. First of all you should work with space consumer that doesn’t eat newlines automatically. This means you’ll need to pick them up manually.</p>
<p>Main helper is called <code>indentGuard</code>. It takes parser that will be used to consume white space (indentation) and a predicate of type <code>Int -&gt; Bool</code>. If after running the given parser column number does not satisfy given predicate, the parser fails with message “incorrect indentation”, otherwise it returns current column number.</p>
<p>In simple cases you can explicitly pass around value returned by <code>indentGuard</code>, i.e. current level of indentation. If you prefer to preserve some sort of state you can achieve backtracking state combining <code>StateT</code> and <code>ParsecT</code>, like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StateT</span> <span class="dt">Int</span> <span class="dt">Parser</span> a</code></pre></div>
<p>Here we have state of type <code>Int</code>. You can use <code>get</code> and <code>put</code> as usual, although it may be better to write modified version of <code>indentGuard</code> that could get current indentation level (indentation level on previous line), then consume indentation of current line, perform necessary checks, and put new level of indentation.</p>
<p><em>Later update</em>: now we have full support for indentation-sensitive parsing, see <code>nonIndented</code>, <code>indentBlock</code>, and <code>lineFold</code> in the <code>Text.Megaparsec.Lexer</code> module.</p>
<h3 id="character-and-string-literals">Character and string literals</h3>
<p>Parsing of string and character literals is done a bit differently than in Parsec. You have the single helper <code>charLiteral</code>, which parses a character literal. It <em>does not</em> parse surrounding quotes, because different languages may quote character literals differently. Purpose of this parser is to help with parsing of conventional escape sequences (literal character is parsed according to rules defined in Haskell report).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">charLiteral ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
charLiteral <span class="fu">=</span> char <span class="ch">'\''</span> <span class="fu">*&gt;</span> charLiteral <span class="fu">&lt;*</span> char <span class="ch">'\''</span></code></pre></div>
<p>Use <code>charLiteral</code> to parse string literals. This is simplified version that will accept plain (not escaped) newlines in string literals (it’s easy to make it conform to Haskell syntax, this is left as an exercise for the reader):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stringLiteral ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
stringLiteral <span class="fu">=</span> char <span class="ch">'&quot;'</span> <span class="fu">&gt;&gt;</span> manyTill L.charLiteral (char <span class="ch">'&quot;'</span>)</code></pre></div>
<p>I should note that in <code>charLiteral</code> we use built-in support for parsing of all the tricky combinations of characters. On the other hand Parsec re-implements the whole thing. Given that it mostly has no tests at all, I cannot tell for sure that it works.</p>
<h3 id="numbers">Numbers</h3>
<p>Parsing of numbers is easy:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">integer ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span>
integer <span class="fu">=</span> lexeme L.integer

<span class="ot">float ::</span> <span class="dt">Parser</span> <span class="dt">Double</span>
float <span class="fu">=</span> lexeme L.float

<span class="ot">number ::</span> <span class="dt">Parser</span> <span class="dt">Scientific</span>
number lexeme L.number <span class="co">-- similar to ‘naturalOrFloat’ in Parsec</span></code></pre></div>
<p>Note that Megaparsec internally uses standard Haskell functions to parse floating point numbers, thus no precision loss is possible (and it’s tested). On the other hand, Parsec again re-implements the whole thing. Approach taken by Parsec authors is to parse the numbers one by one and then re-create the floating point number by means of floating point arithmetic. Any professional knows that this is not possible and the only way to parse floating point number is via bit-level manipulation (it’s usually done on OS level, in C libraries). Of course results produced by Parsec built-in parser for floating point numbers are incorrect. This is a known bug now, but it’s been a long time till we “discovered” it, because again, Parsec has no test suite. (<em>Update</em>: it took one year but Parsec’s maintainer has recently merged a pull request that seems to fix that and released Parsec 3.1.11.)</p>
<p>Hexadecimal and octal numbers do not parse “0x” or “0o” prefixes, because different languages may have other prefixes for this sort of numbers. We should parse the prefixes manually:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hexadecimal ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span>
hexadecimal <span class="fu">=</span> lexeme <span class="fu">$</span> char <span class="ch">'0'</span> <span class="fu">&gt;&gt;</span> char' <span class="ch">'x'</span> <span class="fu">&gt;&gt;</span> L.hexadecimal

<span class="ot">octal ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span>
octal <span class="fu">=</span> lexeme <span class="fu">$</span> char <span class="ch">'0'</span> <span class="fu">&gt;&gt;</span> char' <span class="ch">'o'</span> <span class="fu">&gt;&gt;</span> L.octal</code></pre></div>
<p>Since Haskell report says nothing about sign in numeric literals, basic parsers like <code>integer</code> do not parse sign. You can easily create parsers for signed numbers with help of <code>signed</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">signedInteger ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span>
signedInteger <span class="fu">=</span> L.signed sc integer

<span class="ot">signedFloat ::</span> <span class="dt">Parser</span> <span class="dt">Double</span>
signedFloat <span class="fu">=</span> L.signed sc float

<span class="ot">signedNumber ::</span> <span class="dt">Parser</span> <span class="dt">Scientific</span>
signedNumber <span class="fu">=</span> L.signed sc number</code></pre></div>
<p>And that’s it, shiny and new, <code>Text.Megaparsec.Lexer</code> is at your service, now you can implement anything you want without the need to copy and edit entire <code>Text.Parsec.Token</code> module (people had to do it sometimes, you know).</p>
<h2 id="whats-next">What’s next?</h2>
<p>Changes you may want to perform may be more fundamental than those described here. For example, previously you may have to use a workaround because <code>Text.Parsec.Token</code> was not sufficiently flexible. Now you can replace it with a proper solution. If you want to use the full potential of Megaparsec, take time to read about its features, they can help you improve your parsers.</p>



            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.1.0/anchor.min.js"></script>
    <script src="../js/put-anchors.js"></script>
  </body>
</html>
