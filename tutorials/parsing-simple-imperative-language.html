<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content />
    <meta name="author" content />
    <title>Megaparsec | Parsing a simple imperative language</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="../css/megaparsec.css" />
  </head>

  <body>

    <div class="navbar navbar-default navbar-static-top" role="navigation">
      <div class="container-fluid">
        <div class="navbar-header">
          <a class="navbar-brand" href="../">
            Megaparsec
          </a>
        </div>
        <div class="navbar-right">
          <ul class="nav navbar-nav">
            
            <li>
              <a href="../tutorials.html">Tutorials</a>
            </li>
            
            <li>
              <a href="https://hackage.haskell.org/package/megaparsec">Hackage</a>
            </li>
            
            <li>
              <a href="https://github.com/mrkkrp/megaparsec">GitHub</a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="row-fluid">
        <div class="col-sm-10 col-sm-offset-1 col-md-8 col-md-offset-2 main">
          <div class="page-header">
            <h1>Parsing a simple imperative language
              
              <br />
              <small>
                Based on original Parsec tutorial
              </small>
              
            </h1>
            <hr />
            <div class="content">
              
<em>Last updated on May 14, 2015</em>
<hr />


<p>This tutorial will present how to parse a subset of a simple imperative programming language called <em>WHILE</em> (introduced in the book “Principles of Program Analysis” by Nielson, Nielson and Hankin). It includes only a few statements and basic boolean/arithmetic expressions, which makes it nice material for a tutorial.</p>
<ol style="list-style-type: decimal">
<li><a href="#imports">Imports</a></li>
<li><a href="#the-language">The language</a></li>
<li><a href="#data-structures">Data structures</a></li>
<li><a href="#lexer">Lexer</a></li>
<li><a href="#parser">Parser</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#notes">Notes</a></li>
</ol>
<h2 id="imports">Imports</h2>
<p>First let’s specify the name of the module:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">ParseWhile</span> <span class="kw">where</span></code></pre></div>
<p>And then import the necessary libraries:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span> (void)
<span class="kw">import </span><span class="dt">Text.Megaparsec</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.Expr</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.String</span> <span class="co">-- input stream is of type ‘String’</span>
<span class="kw">import qualified</span> <span class="dt">Text.Megaparsec.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></code></pre></div>
<h2 id="the-language">The language</h2>
<p>The grammar for expressions is defined as follows:</p>
<pre><code>a   ::= x | n | - a | a opa a
b   ::= true | false | not b | b opb b | a opr a
opa ::= + | - | * | /
opb ::= and | or
opr ::= &gt; | &lt;</code></pre>
<p>Note that we have three groups of operators — arithmetic, boolean and relational ones.</p>
<p>And now the definition of statements:</p>
<pre><code>S ::= x := a | skip | S1; S2 | ( S ) | if b then S1 else S2 | while b do S</code></pre>
<p>We probably want to parse that into some internal representation of the language (an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a>). Therefore we need to define the data structures for the expressions and statements.</p>
<h2 id="data-structures">Data structures</h2>
<p>We need to take care of boolean and arithmetic expressions and the appropriate operators. First let’s look at the boolean expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BExpr</span> <span class="fu">=</span> <span class="dt">BoolConst</span> <span class="dt">Bool</span>
           <span class="fu">|</span> <span class="dt">Not</span> <span class="dt">BExpr</span>
           <span class="fu">|</span> <span class="dt">BBinary</span> <span class="dt">BBinOp</span> <span class="dt">BExpr</span> <span class="dt">BExpr</span>
           <span class="fu">|</span> <span class="dt">RBinary</span> <span class="dt">RBinOp</span> <span class="dt">AExpr</span> <span class="dt">AExpr</span>
             <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>Binary boolean operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BBinOp</span> <span class="fu">=</span> <span class="dt">And</span> <span class="fu">|</span> <span class="dt">Or</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>Relational operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">RBinOp</span> <span class="fu">=</span> <span class="dt">Greater</span> <span class="fu">|</span> <span class="dt">Less</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>Now we define the types for arithmetic expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AExpr</span> <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">String</span>
           <span class="fu">|</span> <span class="dt">IntConst</span> <span class="dt">Integer</span>
           <span class="fu">|</span> <span class="dt">Neg</span> <span class="dt">AExpr</span>
           <span class="fu">|</span> <span class="dt">ABinary</span> <span class="dt">ABinOp</span> <span class="dt">AExpr</span> <span class="dt">AExpr</span>
             <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>And arithmetic operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ABinOp</span> <span class="fu">=</span> <span class="dt">Add</span>
            <span class="fu">|</span> <span class="dt">Subtract</span>
            <span class="fu">|</span> <span class="dt">Multiply</span>
            <span class="fu">|</span> <span class="dt">Divide</span>
              <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>Finally let’s take care of the statements:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Stmt</span> <span class="fu">=</span> <span class="dt">Seq</span> [<span class="dt">Stmt</span>]
          <span class="fu">|</span> <span class="dt">Assign</span> <span class="dt">String</span> <span class="dt">AExpr</span>
          <span class="fu">|</span> <span class="dt">If</span> <span class="dt">BExpr</span> <span class="dt">Stmt</span> <span class="dt">Stmt</span>
          <span class="fu">|</span> <span class="dt">While</span> <span class="dt">BExpr</span> <span class="dt">Stmt</span>
          <span class="fu">|</span> <span class="dt">Skip</span>
            <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<h2 id="lexer">Lexer</h2>
<p>Having all the data structures we can go on with writing the code to do the actual parsing. Here we will define <em>lexemes</em> of our language. When writing a lexer for a language it’s always important to define what counts as whitespace and how it should be consumed. <code>space</code> from <code>Text.Megaparsec.Lexer</code> module can be helpful here:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sc ::</span> <span class="dt">Parser</span> ()
sc <span class="fu">=</span> L.space (void spaceChar) lineCmnt blockCmnt
  <span class="kw">where</span> lineCmnt  <span class="fu">=</span> L.skipLineComment <span class="st">&quot;//&quot;</span>
        blockCmnt <span class="fu">=</span> L.skipBlockComment <span class="st">&quot;/*&quot;</span> <span class="st">&quot;*/&quot;</span></code></pre></div>
<p><code>sc</code> stands for “space consumer”. <code>space</code> takes three arguments: a parser that parses single whitespace character, a parser for line comments, and a parser for block (multi-line) comments. <code>skipLineComment</code> and <code>skipBlockComment</code> help with quickly creating parsers to consume the comments. (If our language didn’t have block comments, we could pass <code>empty</code> as the third argument of <code>space</code>.)</p>
<p>Next, we will use a strategy where whitespace will be consumed <em>after</em> every lexeme automatically, but not before it. Let’s define a wrapper to achieve this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
lexeme <span class="fu">=</span> L.lexeme sc</code></pre></div>
<p>Perfect. Now we can wrap any parser in <code>lexeme</code> and it will consume any trailing whitespace with <code>sc</code>.</p>
<p>Since we often want to parse some “fixed” string, let’s define one more parser called <code>symbol</code>. It will take a string as argument and parse this string and whitespace after it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">symbol ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
symbol <span class="fu">=</span> L.symbol sc</code></pre></div>
<p>With these tools we can create other useful parsers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | 'parens' parses something between parenthesis.</span>

<span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
parens <span class="fu">=</span> between (symbol <span class="st">&quot;(&quot;</span>) (symbol <span class="st">&quot;)&quot;</span>)

<span class="co">-- | 'integer' parses an integer.</span>

<span class="ot">integer ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span>
integer <span class="fu">=</span> lexeme L.integer

<span class="co">-- | 'semi' parses a semicolon.</span>

<span class="ot">semi ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
semi <span class="fu">=</span> symbol <span class="st">&quot;;&quot;</span></code></pre></div>
<p>Great. To parse various operators we can just use <code>symbol</code>, but reserved words and identifiers are a bit trickier. There are two points to note:</p>
<ul>
<li><p>Parsers of reserved words should check that the parsed reserved word is not a prefix of an identifier.</p></li>
<li><p>Parsers of identifiers should check that parsed identifier is not a reserved word.</p></li>
</ul>
<p>Let’s express it in code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rword ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()
rword w <span class="fu">=</span> string w <span class="fu">*&gt;</span> notFollowedBy alphaNumChar <span class="fu">*&gt;</span> sc

<span class="ot">rws ::</span> [<span class="dt">String</span>] <span class="co">-- list of reserved words</span>
rws <span class="fu">=</span> [<span class="st">&quot;if&quot;</span>,<span class="st">&quot;then&quot;</span>,<span class="st">&quot;else&quot;</span>,<span class="st">&quot;while&quot;</span>,<span class="st">&quot;do&quot;</span>,<span class="st">&quot;skip&quot;</span>,<span class="st">&quot;true&quot;</span>,<span class="st">&quot;false&quot;</span>,<span class="st">&quot;not&quot;</span>,<span class="st">&quot;and&quot;</span>,<span class="st">&quot;or&quot;</span>]

<span class="ot">identifier ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
identifier <span class="fu">=</span> (lexeme <span class="fu">.</span> try) (p <span class="fu">&gt;&gt;=</span> check)
  <span class="kw">where</span>
    p       <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> letterChar <span class="fu">&lt;*&gt;</span> many alphaNumChar
    check x <span class="fu">=</span> <span class="kw">if</span> x <span class="ot">`elem`</span> rws
                <span class="kw">then</span> fail <span class="fu">$</span> <span class="st">&quot;keyword &quot;</span> <span class="fu">++</span> show x <span class="fu">++</span> <span class="st">&quot; cannot be an identifier&quot;</span>
                <span class="kw">else</span> return x</code></pre></div>
<p><code>identifier</code> may seem complex, but it’s really simple. We just parse a sequence of characters where first character is a letter and the rest is several characters where every one of them can be either letter or number. Once we have parsed such string, we check if it’s in list of reserved words, fail with informative message if it is, and return the result otherwise.</p>
<p>Note the use of <code>try</code> in <code>identifier</code>. This is necessary to backtrack to beginning of the identifier in cases when <code>fail</code> is executed. Otherwise things like <code>many identifier</code> would fail on such identifiers instead of just stopping.</p>
<p>And that’s it, we have just written lexer for our language, now we can start writing parser.</p>
<h2 id="parser">Parser</h2>
<p>As already mentioned, a program in this language is simply a statement, so the main parser should basically only parse a statement. But remember to take care of initial whitespace — our parsers only get rid of whitespace after the tokens!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">whileParser ::</span> <span class="dt">Parser</span> <span class="dt">Stmt</span>
whileParser <span class="fu">=</span> sc <span class="fu">*&gt;</span> stmt <span class="fu">&lt;*</span> eof</code></pre></div>
<p>Now because any statement might be actually a sequence of statements separated by semicolon, we use <code>sepBy1</code> to parse at least one statement. The result is a list of statements. We also allow grouping statements by parentheses, which is useful, for instance, in the <code>while</code> loop.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stmt ::</span> <span class="dt">Parser</span> <span class="dt">Stmt</span>
stmt <span class="fu">=</span> parens stmt <span class="fu">&lt;|&gt;</span> stmtSeq

<span class="ot">stmtSeq ::</span> <span class="dt">Parser</span> <span class="dt">Stmt</span>
stmtSeq <span class="fu">=</span> f <span class="fu">&lt;$&gt;</span> sepBy1 stmt' semi
  <span class="co">-- if there's only one stmt return it without using ‘Seq’</span>
  <span class="kw">where</span> f l <span class="fu">=</span> <span class="kw">if</span> length l <span class="fu">==</span> <span class="dv">1</span> <span class="kw">then</span> head l <span class="kw">else</span> <span class="dt">Seq</span> l</code></pre></div>
<p>Now a single statement is quite simple, it’s either an <code>if</code> conditional, a <code>while</code> loop, an assignment or simply a <code>skip</code> statement. We use <code>&lt;|&gt;</code> to express choice. So <code>a &lt;|&gt; b</code> will first try parser <code>a</code> and if it fails (but without actually consuming any input) then parser <code>b</code> will be used. <em>Note: this means that the order is important.</em></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">stmt' ::</span> <span class="dt">Parser</span> <span class="dt">Stmt</span>
stmt' <span class="fu">=</span> ifStmt <span class="fu">&lt;|&gt;</span> whileStmt <span class="fu">&lt;|&gt;</span> skipStmt <span class="fu">&lt;|&gt;</span> assignStmt</code></pre></div>
<p>If you have a parser that might fail after consuming some input, and you still want to try the next parser, you should take a look at the <code>try</code> combinator. For instance <code>try p &lt;|&gt; q</code> will try parsing with <code>p</code> and if it fails, even after consuming the input, the <code>q</code> parser will be used as if nothing has been consumed by <code>p</code>.</p>
<p>Now let’s define the parsers for all the possible statements. This is quite straightforward as we just use the parsers from the lexer and then use all the necessary information to create appropriate data structures.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ifStmt ::</span> <span class="dt">Parser</span> <span class="dt">Stmt</span>
ifStmt <span class="fu">=</span>
  <span class="kw">do</span> rword <span class="st">&quot;if&quot;</span>
     cond  <span class="ot">&lt;-</span> bExpr
     rword <span class="st">&quot;then&quot;</span>
     stmt1 <span class="ot">&lt;-</span> stmt
     rword <span class="st">&quot;else&quot;</span>
     stmt2 <span class="ot">&lt;-</span> stmt
     return <span class="fu">$</span> <span class="dt">If</span> cond stmt1 stmt2

<span class="ot">whileStmt ::</span> <span class="dt">Parser</span> <span class="dt">Stmt</span>
whileStmt <span class="fu">=</span>
  <span class="kw">do</span> rword <span class="st">&quot;while&quot;</span>
     cond <span class="ot">&lt;-</span> bExpr
     rword <span class="st">&quot;do&quot;</span>
     stmt1 <span class="ot">&lt;-</span> stmt
     return <span class="fu">$</span> <span class="dt">While</span> cond stmt1

<span class="ot">assignStmt ::</span> <span class="dt">Parser</span> <span class="dt">Stmt</span>
assignStmt <span class="fu">=</span>
  <span class="kw">do</span> var  <span class="ot">&lt;-</span> identifier
     void <span class="fu">$</span> symbol <span class="st">&quot;:=&quot;</span>
     expr <span class="ot">&lt;-</span> aExpr
     return <span class="fu">$</span> <span class="dt">Assign</span> var expr

<span class="ot">skipStmt ::</span> <span class="dt">Parser</span> <span class="dt">Stmt</span>
skipStmt <span class="fu">=</span> <span class="dt">Skip</span> <span class="fu">&lt;$</span> rword <span class="st">&quot;skip&quot;</span></code></pre></div>
<h2 id="expressions">Expressions</h2>
<p>What’s left is to parse the expressions. Fortunately Megaparsec provides a very easy way to do that. Let’s define the arithmetic and boolean expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">aExpr ::</span> <span class="dt">Parser</span> <span class="dt">AExpr</span>
aExpr <span class="fu">=</span> makeExprParser aTerm aOperators

<span class="ot">bExpr ::</span> <span class="dt">Parser</span> <span class="dt">BExpr</span>
bExpr <span class="fu">=</span> makeExprParser bTerm bOperators</code></pre></div>
<p>Now we have to define the lists with operator precedence, associativity and what constructors to use in each case.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">aOperators ::</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">AExpr</span>]]
aOperators <span class="fu">=</span>
  [ [<span class="dt">Prefix</span> (symbol <span class="st">&quot;-&quot;</span> <span class="fu">*&gt;</span> pure <span class="dt">Neg</span>) ]
  , [ <span class="dt">InfixL</span> (symbol <span class="st">&quot;*&quot;</span> <span class="fu">*&gt;</span> pure (<span class="dt">ABinary</span> <span class="dt">Multiply</span>))
    , <span class="dt">InfixL</span> (symbol <span class="st">&quot;/&quot;</span> <span class="fu">*&gt;</span> pure (<span class="dt">ABinary</span> <span class="dt">Divide</span>)) ]
  , [ <span class="dt">InfixL</span> (symbol <span class="st">&quot;+&quot;</span> <span class="fu">*&gt;</span> pure (<span class="dt">ABinary</span> <span class="dt">Add</span>))
    , <span class="dt">InfixL</span> (symbol <span class="st">&quot;-&quot;</span> <span class="fu">*&gt;</span> pure (<span class="dt">ABinary</span> <span class="dt">Subtract</span>)) ]
  ]

<span class="ot">bOperators ::</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">BExpr</span>]]
bOperators <span class="fu">=</span>
  [ [<span class="dt">Prefix</span> (rword <span class="st">&quot;not&quot;</span> <span class="fu">*&gt;</span> pure <span class="dt">Not</span>) ]
  , [<span class="dt">InfixL</span> (rword <span class="st">&quot;and&quot;</span> <span class="fu">*&gt;</span> pure (<span class="dt">BBinary</span> <span class="dt">And</span>))
    , <span class="dt">InfixL</span> (rword <span class="st">&quot;or&quot;</span> <span class="fu">*&gt;</span> pure (<span class="dt">BBinary</span> <span class="dt">Or</span>)) ]
  ]</code></pre></div>
<p>In case of prefix operators it is enough to specify which one should be parsed and what is the associated data constructor. Infix operators are defined similarly, but there are several variants of infix constructors for various associativity. Note that the operator precedence depends only on the order of the elements in the list.</p>
<p>Finally we have to define the terms. In case of arithmetic expressions, it is quite simple:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">aTerm ::</span> <span class="dt">Parser</span> <span class="dt">AExpr</span>
aTerm <span class="fu">=</span> parens aExpr
     <span class="fu">&lt;|&gt;</span> <span class="dt">Var</span>      <span class="fu">&lt;$&gt;</span> identifier
     <span class="fu">&lt;|&gt;</span> <span class="dt">IntConst</span> <span class="fu">&lt;$&gt;</span> integer</code></pre></div>
<p>However, the term in a boolean expression is a bit more tricky. In this case, a term can also be an expression with relational operator consisting of arithmetic expressions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bTerm ::</span> <span class="dt">Parser</span> <span class="dt">BExpr</span>
bTerm <span class="fu">=</span>  parens bExpr
     <span class="fu">&lt;|&gt;</span> (rword <span class="st">&quot;true&quot;</span>  <span class="fu">*&gt;</span> pure (<span class="dt">BoolConst</span> <span class="dt">True</span>))
     <span class="fu">&lt;|&gt;</span> (rword <span class="st">&quot;false&quot;</span> <span class="fu">*&gt;</span> pure (<span class="dt">BoolConst</span> <span class="dt">False</span>))
     <span class="fu">&lt;|&gt;</span> rExpr</code></pre></div>
<p>Therefore we have to define a parser for relational expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rExpr ::</span> <span class="dt">Parser</span> <span class="dt">BExpr</span>
rExpr <span class="fu">=</span>
  <span class="kw">do</span> a1 <span class="ot">&lt;-</span> aExpr
     op <span class="ot">&lt;-</span> relation
     a2 <span class="ot">&lt;-</span> aExpr
     return <span class="fu">$</span> <span class="dt">RBinary</span> op a1 a2

<span class="ot">relation ::</span> <span class="dt">Parser</span> <span class="dt">RBinOp</span>
relation <span class="fu">=</span>  (symbol <span class="st">&quot;&gt;&quot;</span> <span class="fu">*&gt;</span> pure <span class="dt">Greater</span>)
        <span class="fu">&lt;|&gt;</span> (symbol <span class="st">&quot;&lt;&quot;</span> <span class="fu">*&gt;</span> pure <span class="dt">Less</span>)</code></pre></div>
<p>And that’s it. We have a quite simple parser which is able to parse a few statements and arithmetic/boolean expressions.</p>
<h2 id="notes">Notes</h2>
<p>If you want to experiment with the parser inside GHCi, these functions might be handy:</p>
<ul>
<li><p><code>parseTest p input</code> applies parser <code>p</code> on input <code>input</code> and prints results.</p></li>
<li><p><code>parseFromFile p filename</code> applies parser <code>p</code> on contents of file <code>filename</code>.</p></li>
</ul>
<hr />
<p>Original Parsec tutorial in Haskell Wiki:</p>
<p><a href="https://wiki.haskell.org/Parsing_a_simple_imperative_language" class="uri">https://wiki.haskell.org/Parsing_a_simple_imperative_language</a></p>



            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.1.0/anchor.min.js"></script>
    <script src="../js/put-anchors.js"></script>
  </body>
</html>
