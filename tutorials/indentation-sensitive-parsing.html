<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content />
    <meta name="author" content />
    <title>Megaparsec | Indentation-sensitive parsing</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="../css/megaparsec.css" />
  </head>

  <body>

    <div class="navbar navbar-default navbar-static-top" role="navigation">
      <div class="container-fluid">
        <div class="navbar-header">
          <a class="navbar-brand" href="../">
            Megaparsec
          </a>
        </div>
        <div class="navbar-right">
          <ul class="nav navbar-nav">
            
            <li>
              <a href="../tutorials.html">Tutorials</a>
            </li>
            
            <li>
              <a href="https://hackage.haskell.org/package/megaparsec">Hackage</a>
            </li>
            
            <li>
              <a href="https://github.com/mrkkrp/megaparsec">GitHub</a>
            </li>
            
            <li>
              <a href="https://github.com/mrkkrp/megaparsec-site">Edit the site</a>
            </li>
            
          </ul>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="row-fluid">
        <div class="col-sm-10 col-sm-offset-1 col-md-8 col-md-offset-2 main">
          <div class="page-header">
            <h1>Indentation-sensitive parsing
              
              <br />
              <small>
                Native, composable solution
              </small>
              
            </h1>
            <hr />
            <div class="content">
              
<em>Last updated on December  2, 2016</em>
<hr />


<p>Megaparsec 4.3.0 introduces new combinators that should be of some use when you want to parse indentation-sensitive input. Megaparsec 5.0.0 adds support for line-folds, completing support for indentation-sensitive parsing. This tutorial shows how these new tools work, compose, and hopefully, <em>feel natural</em> — something we cannot say about ad-hoc solutions to this problem that exist as separate packages to work on top of Parsec, for example.</p>
<ol style="list-style-type: decimal">
<li><a href="#combinator-overview">Combinator overview</a></li>
<li><a href="#parsing-simple-indented-list">Parsing simple indented list</a></li>
<li><a href="#nested-indented-list">Nested indented list</a></li>
<li><a href="#adding-line-folds">Adding line folds</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ol>
<h2 id="combinator-overview">Combinator overview</h2>
<p>From the first release of Megaparsec, there has been the <code>indentGuard</code> function, which is a great shortcut, but kind of pain to use for complex tasks. So, we won’t cover it here, instead we will talk about the new combinators built upon it and available beginning from Megaparsec 4.3.0.</p>
<p>First, we have <code>indentLevel</code>, which is defined just as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indentLevel ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> m <span class="dt">Pos</span>
indentLevel <span class="fu">=</span> sourceColumn <span class="fu">&lt;$&gt;</span> getPosition</code></pre></div>
<p>That’s right, it’s just a shortcut, but I found myself using this idiom so often, so I included it in the public lexer API.</p>
<p>Second, we have <code>nonIndented</code>. This allows to make sure that some input is not indented. Just wrap a parser in <code>nonIndented</code> and you’re done.</p>
<p><code>nonIndented</code> is trivial to write as well:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nonIndented ::</span> <span class="dt">MonadParsec</span> e s m
  <span class="ot">=&gt;</span> m ()              <span class="co">-- ^ How to consume indentation (white space)</span>
  <span class="ot">-&gt;</span> m a               <span class="co">-- ^ How to parse actual data</span>
  <span class="ot">-&gt;</span> m a
nonIndented sc p <span class="fu">=</span> indentGuard sc <span class="dt">EQ</span> (unsafePos <span class="dv">1</span>) <span class="fu">*&gt;</span> p</code></pre></div>
<p>However, it’s a part of a logical model behind high-level parsing of indentation-sensitive input. We state that there are top-level items that are not indented (<code>nonIndented</code> helps to define parsers for them), and that all indented tokens are directly or indirectly are “children” of those top-level definitions. In Megaparsec, we don’t need any additional state to express this. Since indentation is always relative, our idea is to explicitly tie parsers for “reference” tokens and indented tokens, thus defining indentation-sensitive grammar via pure combination of parsers, just like all the other tools in Megaparsec work. This is different from old solutions built on top of Parsec, where you had to deal with ad-hoc state. It’s also more robust and safer, because the less state you have, the better.</p>
<p>So, how do you define an indented block? Let’s take a look at the signature of the <code>indentBlock</code> helper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">indentBlock ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="fu">~</span> <span class="dt">Char</span>)
  <span class="ot">=&gt;</span> m ()              <span class="co">-- ^ How to consume indentation (white space)</span>
  <span class="ot">-&gt;</span> m (<span class="dt">IndentOpt</span> m a b) <span class="co">-- ^ How to parse “reference” token</span>
  <span class="ot">-&gt;</span> m a</code></pre></div>
<p>First, we specify how to consume indentation. An important thing to note here is that this space-consuming parser <em>must</em> consume newlines as well, while tokens (“reference” token and indented tokens) should not normally consume newlines after them.</p>
<p>As you can see, the second argument allows us to parse “reference” token and return a data structure that tells <code>indentBlock</code> what to do next. There are several options:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">IndentOpt</span> m a b
  <span class="fu">=</span> <span class="dt">IndentNone</span> a
    <span class="co">-- ^ Parse no indented tokens, just return the value</span>
  <span class="fu">|</span> <span class="dt">IndentMany</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>) ([b] <span class="ot">-&gt;</span> m a) (m b)
    <span class="co">-- ^ Parse many indented tokens (possibly zero), use given indentation</span>
    <span class="co">-- level (if 'Nothing', use level of the first indented token); the</span>
    <span class="co">-- second argument tells how to get final result, and third argument</span>
    <span class="co">-- describes how to parse an indented token</span>
  <span class="fu">|</span> <span class="dt">IndentSome</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>) ([b] <span class="ot">-&gt;</span> m a) (m b)
    <span class="co">-- ^ Just like 'IndentMany', but requires at least one indented token to</span>
    <span class="co">-- be present</span></code></pre></div>
<p>We can change our mind and parse no indented tokens, we can parse <em>many</em> (that is, possibly zero) indented tokens or require <em>at least one</em> such token. We can either allow <code>indentBlock</code> detect indentation level of first indented token and use that, or manually specify indentation level. This should be flexible enough.</p>
<h2 id="parsing-simple-indented-list">Parsing simple indented list</h2>
<p>Now it’s time to put our new tools into practice. In this section, we will parse a simple indented list of some items. Let’s begin with the import section:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TupleSections #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span> (empty)
<span class="kw">import </span><span class="dt">Control.Monad</span> (void)
<span class="kw">import </span><span class="dt">Text.Megaparsec</span>
<span class="kw">import </span><span class="dt">Text.Megaparsec.String</span>
<span class="kw">import qualified</span> <span class="dt">Text.Megaparsec.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></code></pre></div>
<p>We will need two kinds of space-consumers: one that consumes new lines <code>scn</code> and one that doesn’t <code>sc</code> (actually it only parses spaces and tabs here):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lineComment ::</span> <span class="dt">Parser</span> ()
lineComment <span class="fu">=</span> L.skipLineComment <span class="st">&quot;#&quot;</span>

<span class="ot">scn ::</span> <span class="dt">Parser</span> ()
scn <span class="fu">=</span> L.space (void spaceChar) lineComment empty

<span class="ot">sc ::</span> <span class="dt">Parser</span> ()
sc <span class="fu">=</span> L.space (void <span class="fu">$</span> oneOf <span class="st">&quot; \t&quot;</span>) lineComment empty

<span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
lexeme <span class="fu">=</span> L.lexeme sc</code></pre></div>
<p>Just for fun, we will allow line comments that start with <code>#</code> as well.</p>
<p>Assuming <code>pItemList</code> parses entire list, we can define high-level parser as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parser ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>])
parser <span class="fu">=</span> pItemList <span class="fu">&lt;*</span> eof</code></pre></div>
<p>This will make it consume all input.</p>
<p><code>pItemList</code> is a top-level form that itself is a combination of “reference” token (header of list) and indented tokens (list items), so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pItemList ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>]) <span class="co">-- header and list items</span>
pItemList <span class="fu">=</span> L.nonIndented scn (L.indentBlock scn p)
  <span class="kw">where</span>
    p <span class="fu">=</span> <span class="kw">do</span>
      header <span class="ot">&lt;-</span> pItem
      return (<span class="dt">L.IndentMany</span> <span class="dt">Nothing</span> (return <span class="fu">.</span> (header, )) pItem)</code></pre></div>
<p>For our purposes, an item is a sequence of alpha-numeric characters and dashes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pItem ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
pItem <span class="fu">=</span> lexeme <span class="fu">$</span> some (alphaNumChar <span class="fu">&lt;|&gt;</span> char <span class="ch">'-'</span>)</code></pre></div>
<p>Now, load the code into GHCi and try it with help of <code>parseTest</code> built-in:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> parseTest parser <span class="st">&quot;&quot;</span>
<span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span>
unexpected end <span class="kw">of</span> input
expecting <span class="ch">'-'</span> or alphanumeric character
λ<span class="fu">&gt;</span> parseTest parser <span class="st">&quot;something&quot;</span>
(<span class="st">&quot;something&quot;</span>,[])
λ<span class="fu">&gt;</span> parseTest parser <span class="st">&quot;  something&quot;</span>
<span class="dv">1</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span>
incorrect indentation (got <span class="dv">3</span>, should be equal to <span class="dv">1</span>)
λ<span class="fu">&gt;</span> parseTest parser <span class="st">&quot;something\none\ntwo\nthree&quot;</span>
<span class="dv">2</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span>
unexpected <span class="ch">'o'</span>
expecting end <span class="kw">of</span> input</code></pre></div>
<p>Remember that we’re using <code>IndentMany</code> option, so empty lists are OK, on the other hand built-in combinator <code>space</code> has hidden the phrase “expecting more space” from error messages (usually you don’t want it because it adds noise to all messages), so this error message is perfectly reasonable.</p>
<p>Let’s continue:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> parseTest parser <span class="st">&quot;something\n  one\n    two\n  three&quot;</span>
<span class="dv">3</span><span class="fu">:</span><span class="dv">5</span><span class="fu">:</span>
incorrect indentation (got <span class="dv">5</span>, should be equal to <span class="dv">3</span>)
λ<span class="fu">&gt;</span> parseTest parser <span class="st">&quot;something\n  one\n  two\n three&quot;</span>
<span class="dv">4</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span>
incorrect indentation (got <span class="dv">2</span>, should be equal to <span class="dv">3</span>)
λ<span class="fu">&gt;</span> parseTest parser <span class="st">&quot;something\n  one\n  two\n  three&quot;</span>
(<span class="st">&quot;something&quot;</span>,[<span class="st">&quot;one&quot;</span>,<span class="st">&quot;two&quot;</span>,<span class="st">&quot;three&quot;</span>])</code></pre></div>
<p>This definitely seems to work. Let’s replace <code>IndentMany</code> with <code>IndentSome</code> and <code>Nothing</code> with <code>Just 5</code> (indentation levels are counted from 1, so it will require 4 spaces before indented items):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pItemList ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>])
pItemList <span class="fu">=</span> L.nonIndented scn (L.indentBlock scn p)
  <span class="kw">where</span>
    p <span class="fu">=</span> <span class="kw">do</span>
      header <span class="ot">&lt;-</span> pItem
      return (<span class="dt">L.IndentSome</span> (<span class="dt">Just</span> (unsafePos <span class="dv">5</span>)) (return <span class="fu">.</span> (header, )) pItem)</code></pre></div>
<p>Now:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> parseTest parser <span class="st">&quot;something\n&quot;</span>
<span class="dv">2</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span>
incorrect indentation (got <span class="dv">1</span>, should be greater than <span class="dv">1</span>)
λ<span class="fu">&gt;</span> parseTest parser <span class="st">&quot;something\n  one&quot;</span>
<span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span>
incorrect indentation (got <span class="dv">3</span>, should be equal to <span class="dv">5</span>)
λ<span class="fu">&gt;</span> parseTest parser <span class="st">&quot;something\n    one&quot;</span>
(<span class="st">&quot;something&quot;</span>,[<span class="st">&quot;one&quot;</span>])</code></pre></div>
<p>First message may be a bit surprising, but Megaparsec knows that there must be at least one item in the list, so it checks indentation level and it’s 1, which is incorrect, so it reports it.</p>
<h2 id="nested-indented-list">Nested indented list</h2>
<p>What I like about <code>indentBlock</code> is that another <code>indentBlock</code> can be put inside of it and the whole thing will work smoothly, parsing more complex input with several levels of indentation. No additional effort is required.</p>
<p>Let’s allow list items to have sub-items. For this we will need one new parser, <code>pComplexItem</code> (looks familiar…):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pComplexItem ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>])
pComplexItem <span class="fu">=</span> L.indentBlock scn p
  <span class="kw">where</span>
    p <span class="fu">=</span> <span class="kw">do</span>
      header <span class="ot">&lt;-</span> pItem
      return (<span class="dt">L.IndentMany</span> <span class="dt">Nothing</span> (return <span class="fu">.</span> (header, )) pItem)</code></pre></div>
<p>A couple of edits to <code>pItemList</code> (we’re now parsing more complex stuff, so we need to reflect this in the type signatures):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parser ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [(<span class="dt">String</span>, [<span class="dt">String</span>])])
parser <span class="fu">=</span> pItemList <span class="fu">&lt;*</span> eof

<span class="ot">pItemList ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [(<span class="dt">String</span>, [<span class="dt">String</span>])])
pItemList <span class="fu">=</span> L.nonIndented scn (L.indentBlock scn p)
  <span class="kw">where</span>
    p <span class="fu">=</span> <span class="kw">do</span>
      header <span class="ot">&lt;-</span> pItem
      return (<span class="dt">L.IndentSome</span> <span class="dt">Nothing</span> (return <span class="fu">.</span> (header, )) pComplexItem)</code></pre></div>
<p>If I feed something like this:</p>
<pre><code>first-chapter
  paragraph-one
      note-A # an important note here!
      note-B
  paragraph-two
    note-1
    note-2
  paragraph-three</code></pre>
<p>…into our parser, I get:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Right</span>
  ( <span class="st">&quot;first-chapter&quot;</span>
  , [ (<span class="st">&quot;paragraph-one&quot;</span>,   [<span class="st">&quot;note-A&quot;</span>,<span class="st">&quot;note-B&quot;</span>])
    , (<span class="st">&quot;paragraph-two&quot;</span>,   [<span class="st">&quot;note-1&quot;</span>,<span class="st">&quot;note-2&quot;</span>])
    , (<span class="st">&quot;paragraph-three&quot;</span>, []) ] )</code></pre></div>
<p>And this looks like it works!</p>
<h2 id="adding-line-folds">Adding line folds</h2>
<p><code>lineFold</code> helper is introduced in Megaparsec 5.0.0. A line fold consists of several elements that can be put on one line or on several lines as long as indentation level of subsequent items is greater than indentation level of first item.</p>
<p>Let’s make use of <code>lineFold</code> and add line folds to our program.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pComplexItem ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>])
pComplexItem <span class="fu">=</span> L.indentBlock scn p
  <span class="kw">where</span>
    p <span class="fu">=</span> <span class="kw">do</span>
      header <span class="ot">&lt;-</span> pItem
      return (<span class="dt">L.IndentMany</span> <span class="dt">Nothing</span> (return <span class="fu">.</span> (header, )) pLineFold)

<span class="ot">pLineFold ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
pLineFold <span class="fu">=</span> L.lineFold scn <span class="fu">$</span> \sc' <span class="ot">-&gt;</span>
  <span class="kw">let</span> ps <span class="fu">=</span> some (alphaNumChar <span class="fu">&lt;|&gt;</span> char <span class="ch">'-'</span>) <span class="ot">`sepBy1`</span> try sc'
  <span class="kw">in</span> unwords <span class="fu">&lt;$&gt;</span> ps <span class="fu">&lt;*</span> sc</code></pre></div>
<p><code>lineFold</code> works like this: you give it space consumer that accepts newlines and it gives you special space consumer that you can use in the callback to consume space between elements of line fold. An important thing here is that you should use normal space consumer at the end of line fold or your fold will have no end.</p>
<p>Playing with the final version of our parser is left as an exercise for the reader — you can create “items” that consist of multiple words and as long as they are “line-folded” they will be parsed and concatenated with single space between them.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Note that every sub-list behaves independently — you will see that if you try to feed the parser with various variants of malformed data. And this is no surprise, since no state is shared between different parts of the structure — it’s just assembled purely from simpler parts — sufficiently elegant solution in the spirit of the rest of the library.</p>


<hr />
<p>
  (Psst! Looking for source code for this tutorial?
  It's <a href="https://github.com/mrkkrp/megaparsec-site/tree/master/tutorial-code/IndentationSensitiveParsing.hs">here</a>.)
</p>


            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.1.0/anchor.min.js"></script>
    <script src="../js/put-anchors.js"></script>
  </body>
</html>
